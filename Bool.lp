require open AL_library.Notation

//////////////////////
// Boolean type
//////////////////////
constant symbol bool : Set       // Type of booleans
set declared "ð”¹"
definition ð”¹ â‰” Ï„ bool
constant symbol true  : ð”¹
constant symbol false : ð”¹

// Induction principle on B.
symbol bool_ind : Î p, Ï€(p true) â†’ Ï€(p false) â†’ Î b, Ï€(p b)
rule bool_ind _ $t _  true  â†ª $t
with bool_ind _ _  $f false â†ª $f

////////////////////////////////
//  Some operations
////////////////////////////////

// Negation
//Definition not b :=
//  match b with
//  | true => false
//  | false => true
//  end.
symbol neg : ð”¹ â†’ ð”¹
rule neg true  â†ª false
with neg false â†ª true

// Disjunction
// Definition or b1 b2 :=
//   match b1 with
//   | true => true
//   | false => b2
//   end.
symbol orb : ð”¹ â†’ ð”¹ â†’ ð”¹
set infix left 6 "|" â‰” orb
rule true | _  â†ª true
with _  | true â†ª true
with false | $b â†ª $b
with $b | false â†ª $b

// Conjunction
// Definition andb b1 b2 :=
//  match b1 with
//  | true => b2
//  | false => false
//  end.
symbol andb : ð”¹ â†’ ð”¹ â†’ ð”¹
set infix left 7 "&" â‰” andb
rule true  & $b    â†ª $b
with $b    & true  â†ª $b
with false & _     â†ª false
with _     & false â†ª false

////////////////////////////////////////////////
//  Some examples of functions definitions
////////////////////////////////////////////////

//Definition apply_neg (f : _ -> _ -> bool) b1 b2 :=
//  f (not b1) (not b2).
definition apply_neg (f: _ â†’ _ â†’ ð”¹) b1 b2 â‰” f (neg b1) (neg b2)

// Check apply_neg.
type apply_neg

// Definition nor := apply_neg andb.
definition nor â‰” apply_neg  andb

// Check nor.
type nor

// Definition nor :=
//   apply_neg (fun b1 => fun b2 => b2).
definition nor_lambda â‰” apply_neg (Î»_ b2, b2)

// Eval compute in (nor true false).
compute nor true false

// Definition idb : bool -> bool := fun b => b.
definition idb : ð”¹ â†’ ð”¹ â‰” Î»b, b

// identique Ã 
// Definition idb (b : bool) := b.
definition idb_bis b:ð”¹ â‰” b

//Definition my_first := apply_neg (fun b1 => fun b2 => b1).
definition my_first â‰” apply_neg (Î»b1 _, b1)

//Eval compute in (my_first true false).
compute (my_first true false)

//Definition apply_neg_gen (A:Type) (f:_->_->A) b1 b2 :=
//  f (not b1) (not b2).
definition apply_neg_gen A (f : _ â†’ _ â†’ A) b1 b2 â‰”
    f (neg b1) (neg b2)

// Definition nor2 := apply_neg_gen bool  andb.
definition nor2 â‰” apply_neg_gen ð”¹ andb

// Definition apply_neg_gen2 {A:Type} (f:_->_->A) b1 b2 :=
//  f (not b1) (not b2).
definition apply_neg_gen2 {A} (f : _ â†’ _ â†’ A) b1 b2 â‰”
    f (neg b1) (neg b2)

// Definition nor3 := apply_neg_gen2 andb.
definition nor3 â‰” apply_neg_gen2 andb
