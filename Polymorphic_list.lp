require open amelie.Notation
require open amelie.Bool
require open amelie.Nat
require open amelie.Logic

//////////////////////////////////////
// Type of polymorphic lists
//////////////////////////////////////
// Inductive list {A:Type} : Type :=
// | nil : list A
// | cons : A -> list A -> list A .
constant symbol list : Set â‡’ Set
set declared "ğ•ƒ"
definition ğ•ƒa â‰” Ï„ (list a)
set declared "â–¡"
constant symbol â–¡ {a} : ğ•ƒa
constant symbol cons {a} : Ï„a â‡’ ğ•ƒa â‡’ ğ•ƒa
set infix right 4 "â¸¬" â‰” cons

assert Î»A (l:ğ•ƒA) x y, (cons x (cons y l)) â‰¡ Î»A (l:ğ•ƒA) x y, (xâ¸¬(yâ¸¬l))

//Check list.
type ğ•ƒ

//Notation "[ x ]" := (cons x nil)./@TODO 4

//Notation "[ x ; y ; .. ; z ]" := (cons x (cons y .. (cons z nil) ..)).
// possible ?

// Eval compute in (cons nat 1 (cons nat (S 1) (nil nat))).
compute (1â¸¬(succ 1)â¸¬â–¡)

// Eval compute in (cons bool true (cons bool false (nil bool))).
compute (trueâ¸¬false â¸¬â–¡)

// Definition id (A:Type) (x:A) := x.
definition id A x:A â‰” x

// Induction principle on lists
symbol list_ind {a} (p:ğ•ƒaâ‡’Prop) :
  Ï€(p â–¡) â‡’ (âˆ€x l,Ï€(p l) â‡’ Ï€(p(xâ¸¬l))) â‡’ âˆ€l,Ï€(p l)

/////////////////////////////
// Length of a list
/////////////////////////////
// Fixpoint length (A:Type) (l:list A) :=
//  match l with
//  | nil _ => 0
//  | cons _ _ t => S (length A t)
//  end.
symbol length {a} : ğ•ƒa â‡’ â„•
rule length â–¡ â†’ 0
and length (_ â¸¬ &l) â†’ succ (length &l)

//Eval compute in (length bool
//   (cons bool true
//         (cons bool false (nil bool)))).
compute length (trueâ¸¬false â¸¬â–¡)

///////////////////////////////////
// Concatenation of two lists
///////////////////////////////////
//Fixpoint app (A:Type) l1 l2 :=
//  match l1 with
//  | nil _ => l2
//  | cons _ a l => cons A a (app A l l2)
//    end.
symbol app {a} : ğ•ƒa â‡’ ğ•ƒa â‡’ ğ•ƒa
set infix right 5 "â‹…" â‰” app
rule     â–¡ â‹… &m     â†’ &m
 and (&x â¸¬ &l) â‹… &m â†’ &x â¸¬ (&l â‹… &m)

assert a (x y z:ğ•ƒa) âŠ¢ xâ‹…yâ‹…z â‰¡ xâ‹…(yâ‹…z)
assert a x l m âŠ¢ xâ¸¬lâ‹…m â‰¡ xâ¸¬(lâ‹…m)

// Montrer que le nombre d'Ã©lÃ©ments de la concatÃ©nation de deux listes est
// la somme des nombres des Ã©lÃ©ments de chacune.

// Lemma equal_length : forall l1 l2,
// (length l1) + (length l2) = length (app l1 l2).
// Proof.
// induction l1.
//  * simpl. reflexivity.
//  * simpl. intro l2. rewrite IHl1. reflexivity.
// Defined.
theorem length_app :
  âˆ€A (l1 l2 : ğ•ƒA), Ï€ (((length l1)+(length l2)) = (length (l1 â‹… l2)))
proof
  assume A l1 l2
  apply list_ind
        (Î»z, ((length z)+(length l2)) = (length (zâ‹…l2))) _ _ l1
  reflexivity
  assume x l2 IHl1
  simpl rewrite IHl1 reflexivity
qed

//rule length (&l â‹… &m) â†’ length &l + length &m

// DÃ©finir la fonction qui renverse une liste (on utilisera la fonction
// prÃ©cÃ©dente app)
// et  montrer que reverse(reverse l) = l pour tout l, par induction sur l
symbol reverse {A} : ğ•ƒA â‡’ ğ•ƒA
rule reverse    â–¡     â†’ â–¡
 and reverse  (&vâ¸¬&q) â†’ (reverse &q)â‹…(cons &v â–¡)

// Lemma app_nil : forall l, app l [] = l.
// Proof.
// induction l.
//  + simpl. reflexivity.
//  + simpl. rewrite IHl. reflexivity.
// Defined.
theorem app_nil : âˆ€A (l:ğ•ƒA), Ï€ ((lâ‹…â–¡) = l)
proof
  assume A l
  refine list_ind (Î»z, (zâ‹…â–¡) = z) _ _ _
  // 0. Ï€ (app nil nil = nil)
  reflexivity
  // 1. âˆ€(x:Ï„ A) (l0:Ï„ (list A)),
  // Ï€ (app l0 nil = l0) â‡’ Ï€ (app (x â¸¬ l0) nil = (x â¸¬ l0))
  assume x l IHl
  simpl
  rewrite IHl
  reflexivity
qed

//rule &m â‹… â–¡ â†’ &m

// Lemma app_assoc : forall l1 l2 l3,
// app (app l1 l2) l3 = app l1 (app l2 l3).
// Proof.
// induction l1.
//  + simpl. reflexivity.
//  + simpl. intros l2 l3. rewrite IHl1. reflexivity.
// Defined.
theorem app_assoc :
  âˆ€A (l1 l2 l3 : ğ•ƒA), Ï€ (((l1â‹…l2)â‹…l3)=(l1â‹…(l2â‹…l3)))
proof
  assume A l1 l2 l3
  apply list_ind (Î»z, ((zâ‹…l2)â‹…l3)=(zâ‹…(l2â‹…l3))) _ _ l1
  // 0. Ï€ (app (app nil l2) l3 = app nil (app l2 l3))
  reflexivity
  // 1. âˆ€(x:Ï„ A) (l:Ï„ (list A)), Ï€ (app (app l l2) l3 = app l (app l2 l3)) â‡’
  // Ï€ (app (app (x â¸¬ l) l2) l3 = app (x â¸¬ l) (app l2 l3))
  assume A
  simpl
  assume l IHl
  rewrite IHl reflexivity
qed

//rule (&l â‹… &m) â‹… &n â†’ &l â‹… (&m â‹… &n)

// Lemma special_case : forall l a, cons a l = app [a] l.
// Proof.
// intro l. simpl. reflexivity.
// Defined.
theorem special_case : âˆ€A (l:ğ•ƒA) a, Ï€ (((aâ¸¬â–¡)â‹…l)=(aâ¸¬l))
proof
  assume A l x simpl reflexivity
qed

// Lemma reverse_bis_concat : forall l1 l2,
// reverse_bis (app l1 l2) =
// app (reverse_bis l2) (reverse_bis l1).
// Proof.
// induction l1.
//  + simpl. intro l2. rewrite app_nil. reflexivity.
//  + simpl. intro l2.
//    rewrite IHl1.
//    apply app_assoc.
// Defined.
theorem reverse_concat :
  âˆ€A (l1 l2:ğ•ƒA), Ï€ ((reverse (l1â‹…l2)) = ((reverse l2)â‹…(reverse l1)))
proof
  assume A l1 l2
  apply list_ind
        (Î»z, (reverse (zâ‹…l2)) = ((reverse l2)â‹…(reverse z))) _ _ l1
  simpl
  //refine eq_sym (reverse l2) (app (reverse l2) nil)
  rewrite app_nil A (reverse l2) reflexivity

  simpl assume x l2 IHl1 rewrite IHl1
  apply app_assoc A (reverse l2) (reverse l3) (xâ¸¬â–¡)
qed

// Lemma fixpoint_prop_bis : forall l,
// reverse_bis (reverse_bis l) = l.
// Proof.
// induction l.
//  * reflexivity.
//  * rewrite special_case.
//    repeat rewrite reverse_bis_concat.
//    simpl. rewrite IHl. reflexivity.
// Defined.
theorem fixpoint_reverse : âˆ€A (l:ğ•ƒA), Ï€ (reverse (reverse l) = l)
proof
  assume A l
  apply list_ind (Î»z, reverse (reverse z) = z) _ _
  // 0. Ï€ (reverse (reverse nil) = nil)
  reflexivity
  // 1. âˆ€(x:Ï„ A) (l0:Ï„ (list A)),
  // Ï€ (reverse (reverse l0) = l0) â‡’ Ï€ (reverse (reverse (x â¸¬ l0)) = (x â¸¬ l0))
  assume x l0 IHl
  simpl rewrite reverse_concat A //(reverse l0) (cons x nil)
  simpl rewrite IHl reflexivity
qed

/////////////////////////////////
// Membership
/////////////////////////////////
//Variable A : Type.
//
//Inductive mem : A -> list A -> Prop :=
//  mem_head : forall x l, mem x (cons x l)
//| mem_tail : forall x y l,
//   mem x l -> mem x (cons y l).
symbol mem {A} : Ï„ A â‡’ ğ•ƒA â‡’ Prop
constant symbol mem_head {A} (x:Ï„ A)   (l:ğ•ƒA) : Ï€ (mem x (xâ¸¬l))
constant symbol mem_tail {A} (x y:Ï„ A) (l:ğ•ƒA) :
  Ï€ ((mem x l) âŠƒ (mem x (yâ¸¬l)))

symbol notMemnil {A} : âˆ€(x:Ï„ A), Ï€ (mem x â–¡) â‡’ Ï€ (âŠ¥)
//symbol mem_inv
// Check app.
type app

//Print app.

//Lemma app_left : forall l1 l2 x,
//mem x l1 -> mem x (app l1 l2).
//Proof.
//induction l1;intros l2 x Hyp.
// * inversion Hyp.
// * inversion Hyp.
//     - subst. constructor.
//     - simpl. constructor. apply IHl1. assumption.
//Defined.
theorem app_left : âˆ€A (l1 l2: ğ•ƒA) (x:Ï„ A), Ï€ (mem x l1) â‡’ Ï€ (mem x (l1â‹…l2))
proof
 assume A
  refine list_ind _ _ _
  // 0. âˆ€(x:Ï„ (list A)) (x0:Ï„ A), Ï€ (mem x0 â–¡) â‡’ Ï€ (mem x0 (â–¡ â‹… x))
  assume x x0 Hmemnil apply false_elim apply notMemnil x0 apply Hmemnil
  // 1. âˆ€(x:Ï„ A) (l:Ï„ (list A)), (âˆ€(x:Ï„ (list A)) (x0:Ï„ A), Ï€ (mem x0 l) â‡’ Ï€ (mem x0 (l â‹… x)))
  //            â‡’ âˆ€(x0:Ï„ (list A)) (x1:Ï„ A), Ï€ (mem x1 (x â¸¬ l)) â‡’ Ï€ (mem x1 ((x â¸¬ l) â‹… x0))
  assume x l1 IHl1 l2 x2 Hl1
  simpl
qed //@TODO 14 inversion

//Lemma app_or : forall l1 l2 x, mem x (app l1 l2) -> mem x l1 \/ mem x l2.
//Proof.
//induction l1;intros l2 x Hyp.
// * simpl in Hyp. right. assumption.
// * inversion Hyp.
//     - subst. left. constructor.
//     - simpl. apply IHl1 in H1.
//       destruct H1 as [| Hypliste].
//          + left. constructor. assumption.
//          + right. assumption.
//Defined.
theorem app_or : âˆ€A (l1 l2: ğ•ƒA) (x:Ï„ A),
Ï€ (mem x (l1â‹…l2) âŠƒ (mem x l1) âˆ¨ (mem x l2))
proof
  assume A l1 l2 x
  apply list_ind (Î»z, mem x (zâ‹…l2) âŠƒ (mem x z) âˆ¨ (mem x l2)) _ _ l1
  // 0. Ï€ (mem x (app nil l2)) â‡’ Ï€ (mem x nil âˆ¨ mem x l2)
  simpl assume Hmeml2 apply disj_intro_right refine Hmeml2
//1. âˆ€(x0:Ï„ A) (l:Ï„ (list A)),
//     (Ï€ (mem x (app l l2)) â‡’ Ï€ (mem x l âˆ¨ mem x l2))
// â‡’ Ï€ (mem x (app (x0 â¸¬ l) l2)) â‡’ Ï€ (mem x (x0 â¸¬ l) âˆ¨ mem x l2)
  assume x0 l Hyp1 Hyp2
  simpl
admit //@TODO 15 inversion
