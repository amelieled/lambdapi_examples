require open amelie.Notation
require open amelie.Bool
require open amelie.Nat

// Type of polymorphic lists
// Inductive list {A:Type} : Type :=
// | nil : list A
// | cons : A -> list A -> list A .
constant symbol list : Set â‡’ Set
set declared "ð•ƒ"
definition ð•ƒa â‰” Ï„ (list a)
set declared "â–¡"
constant symbol â–¡ {a} : ð•ƒa
constant symbol cons {a} : Ï„a â‡’ ð•ƒa â‡’ ð•ƒa
set infix right 4 "â¸¬" â‰” cons

assert Î»A (l:ð•ƒA) x y, (cons x (cons y l)) â‰¡ Î»A (l:ð•ƒA) x y, (xâ¸¬(yâ¸¬l))

//Check list.
type ð•ƒ

//Notation "[ x ]" := (cons x nil)./@TODO 4

//Notation "[ x ; y ; .. ; z ]" := (cons x (cons y .. (cons z nil) ..)).
// possible ?

// Eval compute in (cons nat 1 (cons nat (S 1) (nil nat))).
compute (1â¸¬(succ 1)â¸¬â–¡)

// Eval compute in (cons bool true (cons bool false (nil bool))).
compute (trueâ¸¬false â¸¬â–¡)

// Definition id (A:Type) (x:A) := x.
definition id A x:A â‰” x

// Induction principle on lists
symbol list_ind {a} (p:ð•ƒaâ‡’Prop) :
  Ï€(p â–¡) â‡’ (âˆ€x l,Ï€(p l) â‡’ Ï€(p(xâ¸¬l))) â‡’ âˆ€l,Ï€(p l)

/////////////////////////////
// Length of a list
/////////////////////////////
// Fixpoint length (A:Type) (l:list A) :=
//  match l with
//  | nil _ => 0
//  | cons _ _ t => S (length A t)
//  end.
symbol length {a} : ð•ƒa â‡’ â„•
rule length â–¡ â†’ 0
and length (_ â¸¬ &l) â†’ succ (length &l)

//Eval compute in (length bool
//   (cons bool true
//         (cons bool false (nil bool)))).
compute length (trueâ¸¬false â¸¬â–¡)

///////////////////////////////////
// Concatenation of two lists
///////////////////////////////////
//Fixpoint app (A:Type) l1 l2 :=
//  match l1 with
//  | nil _ => l2
//  | cons _ a l => cons A a (app A l l2)
//    end.
symbol app {a} : ð•ƒa â‡’ ð•ƒa â‡’ ð•ƒa
set infix right 5 "â‹…" â‰” app
rule â–¡ â‹… &m â†’ &m
 and (&x â¸¬ &l) â‹… &m â†’ &x â¸¬ (&l â‹… &m)

assert a (x y z:ð•ƒa) âŠ¢ xâ‹…yâ‹…z â‰¡ xâ‹…(yâ‹…z)
assert a x l m âŠ¢ xâ¸¬lâ‹…m â‰¡ xâ¸¬(lâ‹…m)

// Montrer que le nombre d'Ã©lÃ©ments de la concatÃ©nation de deux listes est
// la somme des nombres des Ã©lÃ©ments de chacune.

// Lemma equal_length : forall l1 l2,
// (length l1) + (length l2) = length (app l1 l2).
// Proof.
// induction l1.
//  * simpl. reflexivity.
//  * simpl. intro l2. rewrite IHl1. reflexivity.
// Defined.
theorem sum_length :
  âˆ€A (l1 l2 : L A), Ï€ ((plus (length l1) (length l2)) = (length (app l1 l2)))
proof
  assume A l1 l2
  apply list_ind
        (Î»z, (plus (length z) (length l2)) = (length (app z l2))) _ _ l1
  reflexivity
  assume x l2 IHl1
  simpl rewrite IHl1 reflexivity
qed

// DÃ©finir la fonction qui renverse une liste (on utilisera la fonction
// prÃ©cÃ©dente app)
// et  montrer que reverse(reverse l) = l pour tout l, par induction sur l
symbol reverse {A} : L A â‡’ L A
rule reverse nil          â†’ nil
 and reverse (cons &v &q) â†’ app (reverse &q) (cons &v nil)

// Lemma app_nil : forall l, app l [] = l.
// Proof.
// induction l.
//  + simpl. reflexivity.
//  + simpl. rewrite IHl. reflexivity.
// Defined.
theorem app_nil : âˆ€A (l:L A), Ï€ (app l nil = l)
proof
  assume A l
  apply list_ind (Î»z, app z nil = z) _ _
  // 0. Ï€ (app nil nil = nil)
  reflexivity
  // 1. âˆ€(x:Ï„ A) (l0:Ï„ (list A)),
  // Ï€ (app l0 nil = l0) â‡’ Ï€ (app (x â¸¬ l0) nil = (x â¸¬ l0))
  assume x l IHl
  simpl
  rewrite IHl
  reflexivity
qed

// Lemma app_assoc : forall l1 l2 l3,
// app (app l1 l2) l3 = app l1 (app l2 l3).
// Proof.
// induction l1.
//  + simpl. reflexivity.
//  + simpl. intros l2 l3. rewrite IHl1. reflexivity.
// Defined.
theorem app_assoc :
  âˆ€A (l1 l2 l3 : L A), Ï€ (app (app l1 l2) l3 = app l1 (app l2 l3))
proof
  assume A l1 l2 l3
  apply list_ind (Î»z, app (app z l2) l3 = app z (app l2 l3)) _ _ l1
  // 0. Ï€ (app (app nil l2) l3 = app nil (app l2 l3))
  reflexivity
  // 1. âˆ€(x:Ï„ A) (l:Ï„ (list A)), Ï€ (app (app l l2) l3 = app l (app l2 l3)) â‡’
  // Ï€ (app (app (x â¸¬ l) l2) l3 = app (x â¸¬ l) (app l2 l3))
  assume A
  simpl
  assume l IHl
  rewrite IHl reflexivity
qed

// Lemma special_case : forall l a, cons a l = app [a] l.
// Proof.
// intro l. simpl. reflexivity.
// Defined.
theorem special_case : âˆ€A (l:L A) a, Ï€ (app (cons a nil) l = cons a l)
proof
  assume A l x simpl reflexivity
qed

// Lemma reverse_bis_concat : forall l1 l2,
// reverse_bis (app l1 l2) =
// app (reverse_bis l2) (reverse_bis l1).
// Proof.
// induction l1.
//  + simpl. intro l2. rewrite app_nil. reflexivity.
//  + simpl. intro l2.
//    rewrite IHl1.
//    apply app_assoc.
// Defined.
theorem reverse_concat :
  âˆ€A (l1 l2:L A), Ï€ ((reverse (app l1 l2)) = app (reverse l2) (reverse l1))
proof
  assume A l1 l2
  apply list_ind
        (Î»z, (reverse (app z l2)) = (app (reverse l2) (reverse z))) _ _ l1
  simpl
  //refine eq_sym (reverse l2) (app (reverse l2) nil)
  rewrite app_nil A (reverse l2) reflexivity

  simpl assume x l2 IHl1 rewrite IHl1
  apply app_assoc A (reverse l2) (reverse l3) (cons x nil)
qed

// Lemma fixpoint_prop_bis : forall l,
// reverse_bis (reverse_bis l) = l.
// Proof.
// induction l.
//  * reflexivity.
//  * rewrite special_case.
//    repeat rewrite reverse_bis_concat.
//    simpl. rewrite IHl. reflexivity.
// Defined.
theorem fixpoint_reverse : âˆ€A (l:L A), Ï€ (reverse (reverse l) = l)
proof
  assume A l
  apply list_ind (Î»z, reverse (reverse z) = z) _ _
  // 0. Ï€ (reverse (reverse nil) = nil)
  reflexivity
  // 1. âˆ€(x:Ï„ A) (l0:Ï„ (list A)),
  // Ï€ (reverse (reverse l0) = l0) â‡’ Ï€ (reverse (reverse (x â¸¬ l0)) = (x â¸¬ l0))
  assume x l0 IHl
  simpl rewrite reverse_concat A //(reverse l0) (cons x nil)
  simpl rewrite IHl reflexivity
qed




                 

theorem concat_nil {a} (l:ð•ƒa) : Ï€(l â‹… â–¡ = l)
proof
  assume a
  refine list_ind _ _ _
  // case l = â–¡
  reflexivity
  // case l = x â¸¬ l'
  assume x l' h
  simpl
  rewrite h
  reflexivity
qed

rule &m â‹… â–¡ â†’ &m

theorem length_concat {a} (l m : ð•ƒa) :
  Ï€(length (l â‹… m) = length l + length m)
proof
  assume a
  refine list_ind _ _ _
  // case l = â–¡
  assume m
  reflexivity
  // case l = xâ¸¬l'
  assume x l' h m
  simpl
  rewrite h
  reflexivity
qed

rule length (&l â‹… &m) â†’ length &l + length &m

theorem concat_assoc {a} (l m n : ð•ƒa) : Ï€((l â‹… m) â‹… n = l â‹… (m â‹… n))
proof
  assume a
  refine list_ind _ _ _
  // case l = â–¡
  assume m n
  reflexivity
  // case l = xâ¸¬l'
  assume x l' h m n
  simpl
  rewrite h
  reflexivity
qed

rule (&l â‹… &m) â‹… &n â†’ &l â‹… (&m â‹… &n)


                           /////////////////////////////////
// Exercice 6 - Dernier retour sur les listes
/////////////////////////////////

//Variable A : Type.
//
//Inductive mem : A -> list A -> Prop :=
//  mem_head : forall x l, mem x (cons x l)
//| mem_tail : forall x y l,
//   mem x l -> mem x (cons y l).
symbol mem {A} : Ï„ A â‡’ L A â‡’ Prop
constant symbol mem_head {A} (x:Ï„ A)   (l:L A) : Ï€ (mem x (cons x l))
constant symbol mem_tail {A} (x y:Ï„ A) (l:L A) :
  Ï€ (imp (mem x l) (mem x (cons y l)))

// Check app.
type app

//Print app.

//Lemma app_left : forall l1 l2 x,
//mem x l1 -> mem x (app l1 l2).
//Proof.
//induction l1;intros l2 x Hyp.
// * inversion Hyp.
// * inversion Hyp.
//     - subst. constructor.
//     - simpl. constructor. apply IHl1. assumption.
//Defined.
theorem app_left : âˆ€A (l1 l2: L A) (x:Ï„ A), Ï€ (mem x l1) â‡’ Ï€ (mem x (app l1 l2))
proof
admit //@TODO 14 inversion

//Lemma app_or : forall l1 l2 x, mem x (app l1 l2) -> mem x l1 \/ mem x l2.
//Proof.
//induction l1;intros l2 x Hyp.
// * simpl in Hyp. right. assumption.
// * inversion Hyp.
//     - subst. left. constructor.
//     - simpl. apply IHl1 in H1.
//       destruct H1 as [| Hypliste].
//          + left. constructor. assumption.
//          + right. assumption.
//Defined.
theorem app_or : âˆ€A (l1 l2: L A) (x:Ï„ A),
Ï€ (mem x (app l1 l2) âŠƒ (mem x l1) âˆ¨ (mem x l2))
proof
  assume A l1 l2 x
  apply list_ind (Î»z, mem x (app z l2) âŠƒ (mem x z) âˆ¨ (mem x l2)) _ _ l1
  // 0. Ï€ (mem x (app nil l2)) â‡’ Ï€ (mem x nil âˆ¨ mem x l2)
  simpl assume Hmeml2 apply disj_intro_right apply Hmeml2
//1. âˆ€(x0:Ï„ A) (l:Ï„ (list A)),
//     (Ï€ (mem x (app l l2)) â‡’ Ï€ (mem x l âˆ¨ mem x l2))
// â‡’ Ï€ (mem x (app (x0 â¸¬ l) l2)) â‡’ Ï€ (mem x (x0 â¸¬ l) âˆ¨ mem x l2)
  assume x0 l Hyp1 Hyp2
  simpl
admit //@TODO 15 inversion
