// InspirÃ© de Software_Foundations/lf/Basics.html
require open amelie.lambdapi_examples.Operations
require open amelie.lambdapi_examples.Polymorphic_list
require open amelie.lambdapi_examples.Nat
require open amelie.lambdapi_examples.Bool
require open amelie.lambdapi_examples.Constructive_logic
require open amelie.lambdapi_examples.Notation

// Polymorphic if
symbol if {a} : ğ”¹ â†’ a â†’ a â†’ a
rule if true  $t _  â†ª $t
 with if false _  $f â†ª $f

///////////////////////
// Bags via Lists
///////////////////////

////////////
//  Type
////////////
//definition bag â‰” ğ•ƒnat
definition bag â‰” Ï„ (list nat)
////////////
//  Count
////////////
symbol count : â„• â†’ bag â†’ â„•
rule count _     â–¡    â†ª 0
 with count $x ($yâ¸¬$q) â†ª
        if (eqb_nat $x $y) (succ (count $x $q)) (count $x $q)

definition my_list â‰” 1â¸¬2â¸¬3â¸¬1â¸¬4â¸¬1â¸¬â–¡

theorem test_count1 : Ï€ (count 1 my_list = 3)
proof reflexivity qed

theorem test_count2 : Ï€ (count 6 my_list = 0)
proof reflexivity qed

////////////
//  Sum
////////////
definition sum : bag â†’ bag â†’ bag â‰” app

definition list123 â‰” 1â¸¬2â¸¬3â¸¬â–¡
definition list141 â‰” 1â¸¬4â¸¬1â¸¬â–¡

theorem test_sum1 : Ï€ (count 1 (sum list123 list141) = 3)
proof reflexivity qed

////////////
//  Add
////////////
definition add â‰” cons {nat}

theorem test_add1 : Ï€ (count 1 (add 1 list141) = 3)
proof reflexivity qed

theorem test_add2 : Ï€ (count 5 (add 1 list141) = 0)
proof reflexivity qed

////////////
//  Member
////////////
symbol member : â„• â†’ bag â†’ ğ”¹
rule member _ â–¡ â†ª false
 with member $v ($yâ¸¬$q) â†ª if (eqb_nat $v $y) true (member $v $q)

theorem test_member1 : Ï€ (member 1 list141 = true)
proof reflexivity qed

theorem test_member2 : Ï€ (member 2 list141 = false)
proof reflexivity qed

////////////
//  Remove_one
////////////
symbol remove_one : â„• â†’ bag â†’ bag
rule remove_one _     â–¡    â†ª â–¡
 with remove_one $v ($yâ¸¬$q) â†ª if (eqb_nat $v $y) $q ($yâ¸¬(remove_one $v $q))

theorem test_remove_one1 : Ï€ (count 5 (remove_one 5 (2â¸¬1â¸¬5â¸¬4â¸¬1â¸¬â–¡)) = 0)
proof reflexivity qed

theorem test_remove_one2 : Ï€ (count 5 (remove_one 5 (2â¸¬1â¸¬4â¸¬1â¸¬â–¡)) = 0)
proof reflexivity qed

theorem test_remove_one3 : Ï€ (count 4 (remove_one 5 (2â¸¬1â¸¬4â¸¬5â¸¬1â¸¬4â¸¬â–¡)) = 2)
proof reflexivity qed

theorem test_remove_one4 : Ï€ (count 5 (remove_one 5 (2â¸¬1â¸¬5â¸¬4â¸¬5â¸¬1â¸¬4â¸¬â–¡)) = 1)
proof reflexivity qed

////////////
//  Remove_all
////////////
symbol remove_all : â„• â†’ bag â†’ bag
rule remove_all _ â–¡           â†ª â–¡
 with remove_all $v ($yâ¸¬$q) â†ª if (eqb_nat $v $y) (remove_all $v $q) (cons $y (remove_all $v $q)) 

theorem test_remove_all1 : Ï€ (count 5 (remove_all 5 (2â¸¬1â¸¬5â¸¬4â¸¬1â¸¬â–¡)) = 0)
proof reflexivity qed

theorem test_remove_all2 : Ï€ (count 5 (remove_all 5 (2â¸¬1â¸¬4â¸¬1â¸¬â–¡)) = 0)
proof reflexivity qed

theorem test_remove_all3 : Ï€ (count 4 (remove_all 5 (2â¸¬1â¸¬4â¸¬5â¸¬1â¸¬4â¸¬â–¡)) = 2)
proof reflexivity qed

theorem test_remove_all4 : Ï€ (count 5 (remove_all 5 (2â¸¬1â¸¬5â¸¬4â¸¬5â¸¬1â¸¬4â¸¬5â¸¬1â¸¬4â¸¬â–¡)) = 0)
proof reflexivity qed

////////////
//  Subset
////////////
symbol subset : bag â†’ bag â†’ ğ”¹
rule subset    â–¡ _       â†ª true
 with subset ($xâ¸¬$q1) $b2 â†ª
         andb (leb_nat (count $x ($xâ¸¬$q1)) (count $x $b2))
                       (subset $q1 (remove_one $x $b2))

theorem test_subset1 : Ï€ (subset (1â¸¬2â¸¬â–¡) (2â¸¬list141) = true)
proof reflexivity qed

theorem test_subset2 : Ï€ (subset (1â¸¬2â¸¬2â¸¬â–¡) (2â¸¬list141) = false)
proof reflexivity qed
