require open amelie.lambdapi_examples.Notation
require open amelie.lambdapi_examples.Constructive_logic
require open amelie.lambdapi_examples.Discriminate
require open amelie.lambdapi_examples.Bool
require open amelie.lambdapi_examples.Nat
//require open amelie.Op_bool

//////////////////////////
//  Un exemple de prÃ©dicat inductif : even
//////////////////////////

//Definition is_even n := exists p, n = 2 * p.
definition is_even n â‰” âˆƒ(Î»p, n = (2Ã—p))

//Lemma zero_is_even : is_even 0.
//Proof.
//unfold is_even.
//exists 0. simpl. reflexivity.
//Defined.
theorem zero_is_even : Ï€ (is_even 0)
proof
  apply ex_intro (Î»p, 0 = ((succ (succ 0))Ã—p)) 0
  reflexivity
qed

//Lemma is_even_plus : forall n p,
//   is_even n -> is_even p -> is_even (n + p).
//Proof.
//intros n p Hn Hp.
//unfold is_even in Hn.
//destruct Hn as [k Hk].
//destruct Hp as [t Ht].
//unfold is_even.
//exists (k + t).
//rewrite  mult_plus_distr_l.
//rewrite Hk.  rewrite Ht. reflexivity.
//Qed.
theorem is_even_plus :
  Î n p, Ï€ (is_even n) â†’ Ï€ (is_even p) â†’ Ï€ (is_even (n+p))
proof
  assume n p Hn Hp
  apply ex_elim (Î»p, n = ((succ (succ 0))Ã—p))   apply Hn assume x Hx
  apply ex_elim (Î»p0, p = ((succ (succ 0))Ã—p0)) apply Hp assume y Hy
  apply ex_intro (Î»p0, (n+p) = ((succ (succ 0))Ã—p0)) (x+y)
  rewrite mult_plus_distr_l
  rewrite  Hx rewrite Hy reflexivity
qed

// On rappelle la dÃ©finition de [even] sous forme d'un prÃ©dicat inductif.

//Inductive even : nat -> Prop :=
//| even_0 : even 0
//| even_SS : forall n, even n -> even (succ (succ n)).
symbol even : â„• â†’ Prop
constant symbol even_0 : Ï€ (even 0)
constant symbol even_SS n : Ï€ (imp (even n) (even (succ (succ n))))
constant symbol even_0_coq : Ï€ (even 0)
constant symbol even_SS_coq n : Ï€ (even n) â†’ Ï€ (even (succ (succ n)))

symbol even_ind : Î p, Ï€ (p 0) â†’ (Î n, Ï€ (even n) â†’ Ï€ (p n) â†’ Ï€ (p (succ (succ n)))) â†’ Î n, Ï€ (even n) â†’ Ï€ (p n)

// symbol even_inject : Î n, (Ï€ (n = 0) â†’ Ï€ (even 0))
//   â†’ (Ï€ (âˆƒ(Î»p,n = succ (succ p) âŠƒ even p âŠƒ even (succ (succ p)))) â†’ Ï€ (even n))
// symbol even_inj : Î n,  Ï€ (even n) â†’ (Ï€ (n = 0) â†’ Ï€ (even 0))
//   â†’ (Ï€ (âˆƒ(Î»p,n = succ (succ p) âŠƒ even p âŠƒ even (succ (succ p)))))

//Lemma even_4 : even 4.
//Proof.
//apply even_SS. apply even_SS. apply even_0.
//Qed.
// theorem even_4 : Ï€ (even 4)
// proof
//   apply imp_elim (even  (succ (succ O))) apply even_S (succ (succ O))
//   apply imp_elim (even  O) apply even_SS O
//   apply even_0
// qed
theorem even_4_coq : Ï€ (even 4)
proof
  apply even_SS_coq (succ (succ 0)) apply even_SS_coq 0 apply even_0
qed

//                             ou avec une syntaxe fonctionnelle
//Theorem even_4' : even 4.
//Proof. exact (even_SS 2 (even_SS 0 even_0)).
//Qed.
theorem even_4' : Ï€ (even 4)
proof
  apply (even_SS_coq (succ (succ 0)) (even_SS_coq 0 even_0))
qed

//Theorem even_plus4 : forall n, even n -> even (4 + n).
//Proof.
//  intros n. simpl. intros Hn.
//  apply even_SS. apply even_SS. assumption.
//Qed.
//theorem even_plus4 : Ï€ (all (Î»n:N) (imp (even n) (even (plus 4 n))))
theorem even_plus4 : Î n, Ï€ (imp (even n) (even (4+n)))
proof
  assume n Heven
  apply even_SS_coq (succ (succ n))
  apply even_SS_coq n
  apply Heven
qed

//Theorem ev_minus2 : forall n,
//  even n -> even (pred (pred n)).
//Proof.
//  intros n H.
//  inversion H  as [| p Hp].
//  - (* H = even_0 *) simpl. apply even_0.
//  - (* H = even_SS p Hp *) simpl. exact Hp (* ou assumption*).
//Qed.
symbol pred : â„• â†’ â„•
rule pred     0     â†ª 0
 with pred (succ $n) â†ª $n

theorem succ_pred : Î n, Ï€ (Â¬ (n = 0)) â†’ Ï€ (succ (pred n) = n) // inutile
proof
  refine nat_ind _ _ _
  // 0. (Ï€ (zero = zero) â†’ Ï€ âŠ¥) â†’ Ï€ (succ (pred zero) = zero)
  simpl assume Hfalse apply false_elim apply Hfalse reflexivity
  // 1. Î (x:Ï„ nat), ((Ï€ (x = zero) â†’ Ï€ âŠ¥) â†’ Ï€ (succ (pred x) = x)) â†’ (Ï€ (succ x = zero) â†’ Ï€ âŠ¥)
  //                         â†’ Ï€ (succ (pred (succ x)) = succ x)
  assume x Hnotzero Hsuccpredx
  reflexivity
qed

symbol even_inv : Î n, Ï€ (even (succ (succ n))) â†’ Ï€ (even n)
symbol notEven1 : Ï€ (even 1) â†’ Ï€ (âŠ¥)

theorem ev_minus2 : Î n, Ï€ (imp (even n) (even (pred (pred n))))
proof
  //assume n Heven
  refine even_ind _ _ _
  //0. Ï€ (even (pred (pred zero)))
  simpl apply even_0
  //1. Î (n:Ï„ nat), Ï€ (even n) â†’ Ï€ (even (pred (pred n))) â†’ Ï€ (even (pred (pred (succ (succ n)))))
  assume n Heven Hpredpred
  simpl apply Heven
qed// @DONE even_1 inversion

//Theorem even5_nonsense :
//  even 5 -> 2 + 2 = 9.
//Proof.
//  intro H.
//  inversion H.
//  inversion H1.
//  inversion H3.
//Qed.
theorem even5_nonsense : Ï€ (even 5) â†’ Ï€ ((2+2) = 9)
proof
  assume H5
  apply false_elim
  apply notEven1
  apply even_inv (succ zero)
  apply even_inv (succ (succ (succ zero))) apply H5
qed //@DONE even_2 inversion/adaptation

//Lemma ev_even : forall n,
//  even n -> exists k, n = 2 * k.
//Proof.
//  intros n E.
//  induction E as [|k Hk IH].
//  - (* E = even_0 *)
//    exists 0. reflexivity.
//  - (* E = even_SS k Hk
//       with IH : exists k', n' = double k' *)
//    destruct IH as [k' Hk'].
//    rewrite Hk'. exists (succ k'). simpl.
//    Search plus.
//    rewrite <- plus_n_Sm.
//    replace (k' + 0) with k'. reflexivity.
//    apply plus_n_O.
//Qed.
theorem ev_even : Î n, Ï€ (even n) â†’ Ï€ (âˆƒ(Î»k, n = (2Ã—k)))
proof
  refine even_ind _ _ _
  // 0. Ï€ (âˆƒ (Î»k, zero = (succ (succ zero) Ã— k)))
  apply ex_intro _ 0 reflexivity
  // 1. Î (n:Ï„ nat), Ï€ (even n) â†’ Ï€ (âˆƒ (Î»k, n = (succ (succ zero) Ã— k))) â†’ Ï€ (âˆƒ (Î»k, succ (succ n) = (succ (succ zero) Ã— k)))
  assume n Hevenn Hex
  apply ex_elim (Î»k, n = (succ (succ zero) Ã— k)) apply Hex
  assume x Hx apply ex_intro _ (x+1) rewrite Hx simpl
  rewrite plus_n_Sm
//    replace (k' + 0) with k'. reflexivity.
  rewrite plus_n_0 rewrite plus_n_0 simpl
  rewrite plus_n_Sm simpl reflexivity
qed

//  Prouver les lemmes suivants.

//Lemma even_n_disj_succn : forall n, even n \/ even (succ n).
//Proof.
//induction n.
// * left. constructor.
// * destruct IHn.
//    + right. constructor. assumption.
//    + left. assumption.
//Defined.
theorem even_n_disj_succn : Î n, Ï€ (even n âˆ¨ even (succ n))
proof
  assume n
  apply nat_ind (Î»z, even z âˆ¨ even (succ z)) _ _ n
  // 0. Ï€ (even O âˆ¨ even (succ O))
  apply disj_intro_left apply even_0_coq
  //1. Î (x:Ï„ nat), Ï€ (even x âˆ¨ even (succ x)) â†’ Ï€ (even (succ x) âˆ¨ even (succ (succ x)))
  assume x HypOr
  apply disj_elim (even x) (even (succ x))
        // 0. Ï€ (even x âˆ¨ even (succ x))
        apply HypOr
        // 1. Ï€ (even x) â†’ Ï€ (even (succ x) âˆ¨ even (succ (succ x)))
        assume Hevenx
        apply disj_intro_right
        apply even_SS_coq x apply Hevenx
        // 2. Ï€ (even (succ x)) â†’ Ï€ (even (succ x) âˆ¨ even (succ (succ x)))
        assume Hevensuccx
        apply disj_intro_left apply Hevensuccx
qed

//Lemma even_n_neg_succn : forall n, even n -> ~ even (succ n).
//Proof.
//induction n;intro Hyp1;unfold not;intro Hyp2.
//  * inversion Hyp2.
//  * inversion Hyp2. unfold not in IHn. apply IHn;assumption.
//Defined.
theorem even_n_neg_succn : Î n, Ï€ (even n) â†’ Ï€ (Â¬ (even (succ n)))
proof
  refine nat_ind _ _ _
  // 0. Ï€ (even zero) â†’ Ï€ (even (succ zero)) â†’ Ï€ âŠ¥
  assume Heven0 refine notEven1
  // 1. Î (x:Ï„ nat), (Ï€ (even x) â†’ Ï€ (even (succ x)) â†’ Ï€ âŠ¥) â†’ Ï€ (even (succ x)) â†’ Ï€ (even (succ (succ x))) â†’ Ï€ âŠ¥
  assume x IHx Hsucc Hsuccsucc
  apply IHx
        // 0. Ï€ (even x)
        apply even_inv x refine Hsuccsucc
        // 1. Ï€ (even (succ x))
        apply Hsucc
qed //@DONE even_3 inversion

//Lemma even_dec : forall n, even n \/ ~ even n.
//Proof.
//intro n.
//assert(even n \/ even (succ n)) by (apply even_n_or_succn).
//destruct H as [| HypN].
//  * left. assumption.
//  * right. intro H. apply even_n_not_succn in H.
//    contradiction.
//Defined.
theorem even_dec : Î n, Ï€ (even n âˆ¨ Â¬(even n))
proof
  assume n
  apply disj_elim (even n) (even (succ n))
  apply even_n_disj_succn n
     // 0. Ï€ (even n) â†’ Ï€ (even n âˆ¨ Â¬ (even (succ n)))
     assume Hn apply disj_intro_left apply Hn
     //1. Ï€ (even (succ n)) â†’ Ï€ (even n âˆ¨ Â¬ (even (succ n)))
     assume Hsuccn apply disj_intro_right
     assume Hn
     refine even_n_neg_succn n Hn Hsuccn
qed

//  Induction de 2 en 2.
//Lemma two_steps_induction : forall P : nat -> Prop, P 0 -> P 1 ->
//  (forall n, P n -> P (succ (succ n))) ->
//  forall n, P n.
//Proof.
//  intros P H0 H1 IHn.
//  assert (forall n, P n /\ P (succ n)) as Hn.
//   - induction n.
//      + split;assumption.
//      + decompose [and] IHn0. apply IHn in H.
//        split;assumption.
//   - induction n.
//      + assumption.
//      + assert(P n /\ P (succ n)) by (apply Hn).
//        decompose [and] H. assumption.
//Defined.
theorem assert_for_two_steps_induction : Î p, Ï€ (p 0) â†’ Ï€ (p 1) â†’
(Î n, Ï€ (p n) â†’ Ï€ (p (succ (succ n)))) â†’
(Î n, Ï€ (p n âˆ§ p (succ n)))
proof
  assume p Hp0 Hp1 Hn
  refine nat_ind _ _ _
  // 0. Ï€ (p zero âˆ§ p (succ zero))
  apply conj_intro refine Hp0 apply Hp1
  // 1. Î (x:Ï„ nat), Ï€ (p x âˆ§ p (succ x)) â†’ Ï€ (p (succ x) âˆ§ p (succ (succ x)))
  assume x Hx
  apply conj_intro
         // 0. Ï€ (p (succ x))
         apply conj_elim_right (p x) apply Hx
         //1. Ï€ (p (succ (succ x)))
         apply Hn x
         apply conj_elim_left _ (p (succ x)) apply Hx
qed

theorem two_steps_induction : Î (p : â„• â†’ Prop),
Ï€(p 0) â†’ Ï€(p 1) â†’ Ï€ (âˆ€ (Î»n, p n âŠƒ p (succ (succ n)))) â†’
Ï€ (âˆ€ (Î»n, p n))
proof
  assume p Hp0 Hp1 IHn
  refine nat_ind _ _ _
  // 0. Ï€ (p zero)
  apply Hp0
  //1. Î (x:Ï„ nat), Ï€ (p x) â†’ Ï€ (p (succ x))
  //assert(P n /\ P (succ n)) by (apply Hn).
//        decompose [and] H. assumption
  assume x Hx
  apply conj_elim_right (p x)
  refine assert_for_two_steps_induction p Hp0 Hp1 IHn x
qed

// DÃ©finir [evenb : nat -> bool] qui teste si un entier est pair.

//Fixpoint evenb (n:nat) : bool := match n with
//| O => true
//| succ a => negb (evenb a)
symbol evenb : â„• â†’ ð”¹
rule evenb     0     â†ª true
 with evenb (succ $a) â†ª neg (evenb $a)

//    Prouver les lemmes suivants. succi vous avez besoin de rÃ©sultats sur les
//    boolÃ©ens, vous pouvez les trouver dans [Bool]
//    (utiliser [Require Import Bool.]).

//Lemma evenb_correct : forall n, evenb n = true -> even n.
//Proof.
//intros n H. induction n using two_steps_induction.
// + constructor.
// + inversion H.
// + constructor. apply IHn.
//   inversion H.
//   apply Bool.negb_involutive_reverse.
//Defined.
theorem neg_involutive_reverse : Î b, Ï€ (b = neg (neg b))
proof
  refine bool_ind _ _ _
  // 0. Ï€ (true = neg (neg true))
  reflexivity
  //1. Ï€ (false = neg (neg false))
  reflexivity
qed

theorem evenb_correct : Î n, Ï€ (evenb n = true) â†’ Ï€ (even n)
proof
  refine two_steps_induction _ _ _ _
  // 0. Ï€ (evenb zero = true) â†’ Ï€ (even zero)
  assume H0 apply even_0
  // 1. Ï€ (evenb (succ zero) = true) â†’ Ï€ (even (succ zero))
  simpl assume Hfalsetrue
  apply false_elim apply discr_f_t apply Hfalsetrue
  // 2. Î (x:Ï„ nat), (Ï€ (evenb x = true) â†’ Ï€ (even x)) â†’ Ï€ (evenb (succ (succ x)) = true) â†’ Ï€ (even (succ (succ x)))
  simpl assume x IHn Hsuccsucc
  apply even_SS_coq x apply IHn
  rewrite neg_involutive_reverse (evenb x) apply Hsuccsucc
qed//@DONE even_4 inversion

//Lemma evenb_complete : forall n, even n -> evenb n = true.
//Proof.
//intros n H. induction n using two_steps_induction.
// + constructor.
// + inversion H.
// + inversion H. apply IHn in H1.
//   simpl.
//   rewrite Bool.negb_involutive_reverse.
//   rewrite H1. reflexivity.
//Defined.
theorem neg_involutive_reverse_trash : Î b, Ï€ (neg (neg b) = b)
proof
  refine bool_ind _ _ _ reflexivity reflexivity
qed

theorem evenb_complete : Î n, Ï€ (even n) â†’  Ï€ (evenb n = true)
proof
  refine two_steps_induction _ _ _ _
  // 0. Ï€ (even zero) â†’ Ï€ (evenb zero = true)
  assume H0 reflexivity
  // 1. Ï€ (even (succ zero)) â†’ Ï€ (evenb (succ zero) = true)
  assume Hsucc0 apply false_elim apply notEven1 apply Hsucc0
  // 2. Î (x:Ï„ nat), (Ï€ (even x) â†’ Ï€ (evenb x = true)) â†’ Ï€ (even (succ (succ x))) â†’ Ï€ (evenb (succ (succ x)) = true)
  simpl assume x IHn Hsuccsucc
  //apply even_SS_coq x apply IHn
  rewrite neg_involutive_reverse_trash
  apply IHn apply even_inv x apply Hsuccsucc
qed //@DONE even_5 inversion

//Definition evenb_spec : forall n, evenb n = true <-> even n.
//Proof.
//split.
// + apply evenb_correct.
// + apply evenb_complete.
//Defined.
theorem evenb_spec : Î n, Ï€ (evenb n = true â‡” even n)
proof
 assume n
  apply conj_intro
  refine evenb_correct n  //assume Hyp apply evenb_correct n Hyp
  refine evenb_complete n //assume Hyp apply evenb_complete n Hyp
qed

// Prouver [even_dec_bis : forall n, even n \/ ~ even n]
// en utilisant [evenb_spec].

//Lemma even_dec_bis : forall n, even n \/ ~ even n.
//Proof.
//intro n. destruct (evenb n) eqn:H.
// * left. apply evenb_correct;assumption.
// * right. unfold not;intro.
//   apply evenb_complete in H0.
//   rewrite H in H0. inversion H0.
//Defined.
symbol bool_case :
Î p b, Ï€((b = true) âŠƒ (p b)) â†’ Ï€((b = false) âŠƒ (p b)) â†’ Ï€(p b)

constant symbol eq_ind2 {a} (x y : Ï„ a) : Ï€ (x = y) â†’ Î p, Ï€ (p x) â†’ Ï€ (p y)

theorem even_dec_bis : Î n, Ï€ (even n âˆ¨ Â¬(even n))
proof
  assume n
  refine bool_case (Î»b, (even n âˆ¨ Â¬(even n))) (evenb n) _ _
  // 0. Ï€ (evenb n = true) â†’ Ï€ (even n âˆ¨ Â¬ (even n))
  assume Hevenbtrue apply disj_intro_left refine evenb_correct n Hevenbtrue
  // 1. Ï€ (evenb n = false) â†’ Ï€ (even n âˆ¨ Â¬ (even n))
  assume Hevenbfalse apply disj_intro_right
  assume Hevenn apply discr_f_t
  refine eq_ind2 (evenb n) false Hevenbfalse (Î»z, z = true) _
  //rewrite Hevenbfalse
  refine evenb_complete n Hevenn
qed //@DONE even_6 destruct eqn + inversion
