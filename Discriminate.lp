require open amelie.Bool
require open amelie.Constructive_logic
require open amelie.Notation

//set declared "<>"
//definition diff a b â‰” Â¬(eq a b)
//set infix left 6 <> â‰” diff
// symbol false_elim p : Ï€ âŠ¥ â†’ Ï€ p

// Discriminate sur les boolÃ©ens :
symbol my_P : ğ”¹ â†’ Prop
rule my_P true  â†ª âŠ¤
 with my_P false â†ª âŠ¥

theorem discr_f_t : Ï€ (false = true) â†’ Ï€ âŠ¥
proof
  assume H
  apply eq_ind false true H my_P
  apply I
qed

symbol my_P_2 : ğ”¹ â†’ Prop
rule my_P_2 false  â†ª âŠ¤
 with my_P_2 true â†ª âŠ¥

theorem discr_t_f : Ï€ (true = false) â†’ Ï€ âŠ¥
proof
  assume H
  apply eq_ind true false H my_P_2
  apply I
qed

// Tentatives de concision :
symbol if {a} : ğ”¹ â†’ a â†’ a â†’ a
rule if true  $t _  â†ª $t
 with if false _  $f â†ª $f

definition my_second_P â‰” Î»b, if b âŠ¤ âŠ¥

theorem discr_2 : Ï€ (false = true) â†’ Ï€ âŠ¥
proof
  assume H
  apply eq_ind false true H my_second_P
  apply I
qed

theorem discr_3 : Ï€ (false = true) â†’ Ï€ âŠ¥
proof
  assume H
  refine eq_ind false true H my_second_P I
qed

//definition test â‰” Î»l r, eq_ind l r ((Î»x y, Ï€(x=y) x y) l r) my_second_P
theorem discrd:  Ï€ (false = true) â†’ Ï€ âŠ¥
proof
  assume H
  //apply test false true H
  //apply I
admit

definition test2 â‰” Î»l r H, eq_ind l r H my_second_P

//definition p â‰” Î»l r, 

theorem discrd_2  : Ï€ (true = false) â†’ Ï€ âŠ¥
proof
  assume H
  //apply test2 true false H
  //apply I
admit
//constant symbol eq_ind {a} (x y : Ï„ a) : Ï€ (x = y) â†’ Î p, Ï€ (p y) â†’ Ï€ (p x)

symbol testj (x y:ğ”¹) (H:(Î»x y, Ï€(x=y))x y) : TYPE
//symbol test2 l r 
type testj true

//definition test â‰”(Î»l r, (Î»b, if b = r âŠ¤ âŠ¥)  l = r)

// Discriminate sur les Nat
require open amelie.Nat
symbol my_P_nat : â„• â†’ Prop
rule my_P_nat 0  â†ª âŠ¤
 with my_P_nat (succ _) â†ª âŠ¥

theorem discr_s_0 : Î n, Ï€ (succ n = 0) â†’ Ï€ âŠ¥
proof
  assume n H
  apply eq_ind (succ n) 0 H my_P_nat
  apply I
qed

symbol discr_prop : Set â†’ Prop
                          //rule discr_prop $v






//symbol contradiction : Prop â†’ Prop â†’ Ï€ âŠ¥

// Tentative de gÃ©nÃ©ralitsation
symbol eq_left {a} {x:Ï„ a} {y:Ï„ a} (H:Ï€(x=y)) : Ï„ a
                                                //rule eq_left _ _ (Ï€($x=_)) â†ª $x
rule eq_left {_} {$x} {_} _ â†ª $x

theorem erer : Î a (x y: Ï„ a) (H:Ï€(x=y)), Ï€ (eq_left H = x)
proof
assume a x y H
  reflexivity
qed

symbol eq_right {a} {x:Ï„ a} {y:Ï„ a} (H:Ï€(x=y)) : Ï„ a
rule eq_right {_} {_} {$y} _ â†ª $y

definition test3 {a} {x:Ï„ a} {y:Ï„ a} (H:Ï€(x=y)) â‰”
  eq_ind (eq_left H) (eq_right H) H //my_second_P

theorem discrd_34  : Ï€ (false = true) â†’ Ï€ âŠ¥
proof
  assume H
  refine test3 H my_second_P I
  //apply test3 H my_second_P
  //apply I
qed

symbol my_P_H {a} {x:Ï„ a} {y:Ï„ a} (H:Ï€(x=y)) : Ï„ a â†’ Prop
rule my_P_H _ (eq_right _) â†ª âŠ¤
 with my_P_H _ (eq_left  _) â†ª âŠ¥
// with my_P_H $h (succ _) â†ª âŠ¥
// with my_P_H $h zero â†ª âŠ¤
//constant symbol eq_ind {a} (x y : Ï„ a) : Ï€ (x = y) â†’ Î p, Ï€ (p y) â†’ Ï€ (p x)

//definition my_P_3 â‰” nat_ind _ _ _ _

definition last_test {a} {x:Ï„ a} {y:Ï„ a} (H:Ï€(x=y)) â‰”
  eq_ind (eq_left H) (eq_right H) H (my_P_H H)

theorem discr_S_0 : Î n, Ï€ (succ n = 0) â†’ Ï€ âŠ¥
proof
  assume n H
  //apply last_test H
  //apply I
admit
