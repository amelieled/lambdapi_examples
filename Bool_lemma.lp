require open amelie.Discriminate
require open amelie.Bool
require open amelie.Constructive_logic
require open amelie.Notation

// Check True. (* True : Prop *)
type true // (* true : B *)

// Check True -> False. (* True -> False : Prop *)
type (âŠ¤ âŠƒ âŠ¥) // imp âŠ¤ âŠ¥ : Prop

type _ â‡’ _ // ?201 â‡’ ?199 : TYPE

// Lemma bool_trivial : forall (P : bool -> Prop) b, P b -> P b.
// Admitted.
theorem bool_trivial : âˆ€p:ð”¹â‡’Prop,âˆ€b, Ï€ (p b) â‡’ Ï€ (p b)
//Ï€ (imp (P b) (P b))
proof
  assume P b H
  apply H
qed

//Lemma bool_ext : forall (P : bool -> Prop), P true /\ P false ->
//  forall b, P b.
//Admitted.
theorem bool_ext :
âˆ€p, Ï€ (p true âˆ§ p false) â‡’ âˆ€b, Ï€(p b)
proof
  assume P Hp b
  refine bool_ind (Î»z, P z) _ _ _
  apply conj_elim_left _ (P false)
  refine Hp
  apply conj_elim_right (P true) _
  apply Hp
qed

//Lemma bool_ext2 : forall (P : bool -> Prop), P true -> P false ->
//  forall b, P b.
//Admitted.
theorem bool_ext2 :
âˆ€p, Ï€ (p true) â‡’ Ï€ (p false) â‡’ âˆ€b, Ï€ (p b)
proof
  assume P HPT HPF b
  refine bool_ind (Î»z, P z) _ _ _
  apply HPT
  apply HPF
qed

//Lemma andb_prop : forall b1 b2,
//  andb b1 b2 = true -> b1 = true /\ b2 = true.
//Proof.
//  intros b1 b2 H.
//  (* introduit les hypothÃ¨ses *)
//  split. (* sÃ©pare le but en deux sous-buts *)
//  - destruct b1. (* raisonnement par cas *)
//    + reflexivity. (* true = true *)
//    + simpl in H. discriminate H. (* false <> true *)
//  - destruct b2. (* raisonnement par cas *)
//    + reflexivity. (* true = true *)
//    + destruct b1 .  (* raisonnement par cas *)
//      * simpl in H. discriminate H. (* false <> true *)
//      * simpl in H. discriminate H. (* false <> true *)
//Qed.
//theorem andb_prop : // Il me manque un outil pour y arriver avec cet Ã©noncÃ©
//âˆ€b1 b2, Ï€ (eq {bool} (andb b1 b2) true) â‡’
//                    Ï€ ((eq {bool} b1 true) âˆ§ (eq {bool} b2 true))
symbol bool_case :
âˆ€p b, Ï€((b = true) âŠƒ (p b)) â‡’ Ï€((b = false) âŠƒ (p b)) â‡’ Ï€(p b)

theorem andb_prop b1 b2
  : Ï€ (imp (andb b1 b2 = true) ((b1 = true) âˆ§ (b2 = true)))
proof
  assume b1 b2 H1
  apply conj_intro
  // 0. Ï€ (b1 = true)
  refine bool_case (Î»z, z = true) b1 _ _  // destruct b1
         // 0. Ï€ (b1 = true) â‡’ Ï€ (b1 = true)
         assume H2 apply H2
         // 1. Ï€ (b1 = false) â‡’ Ï€ (b1 = true)
         assume H2
         apply eq_ind true (andb b1 b2) _ (Î»z, b1 = z)
              // 0. Ï€ (true = andb b1 b2)
              rewrite H1 reflexivity
              // 1. Ï€ (b1 = andb b1 b2)
              rewrite H2 reflexivity
  // 1. Ï€ (b2 = true)
  refine bool_case (Î»z, z = true) b2 _ _ // destruct b2
        // 0. Ï€ (b2 = true) â‡’ Ï€ (b2 = true)
        assume H2 apply H2
        // 1. Ï€ (b2 = false) â‡’ Ï€ (b2 = true)
        assume H2
        apply eq_ind true (andb b1 b2) _ (Î»z, b2 = z)
              // 0. Ï€ (true = andb b1 b2)
              rewrite H1 reflexivity
              // 1. Ï€ (b2 = andb b1 b2)
              rewrite H2 reflexivity
qed

theorem andb_prop2 b1 b2
  : Ï€ (imp (andb b1 b2 = true) ((b1 = true) âˆ§ (b2 = true)))
proof
  assume b1 b2
  refine bool_ind (Î»z, imp (andb z b2 = true) ((z = true) âˆ§ (b2 = true))) _ _ _
  // Case b1 = true
  simpl
  assume H
  apply conj_intro
  reflexivity
  apply H
  // Case b1 = false
  simpl
  assume H
  apply false_elim (false = true âˆ§ b2 = true)
  apply discr_f_t apply H
qed

//[andb_true_iff : forall b1 b2,andb b1 b2 = true <-> b1 = true /\ b2 = true]
//    Montrer [or_true_iff], un rÃ©sultat similaire sur [or].
theorem andb_true_iff b1 b2
  : Ï€ ((andb b1 b2 = true) â‡” ((b1 = true) âˆ§ (b2 = true)))
proof
  assume b1 b2
  refine bool_ind (Î»z, imp ((andb z b2) =  true)
                           (z = true âˆ§ b2 = true) âˆ§
                       imp (z = true âˆ§ b2 = true)
                           ((andb z b2) = true)) _ _ _
  // Case b1 = true
  simpl
  apply conj_intro
    assume H apply conj_intro
      reflexivity
      apply H
    assume H apply conj_elim_right (true = true) apply H
  // Case b1 = false
  simpl
  apply conj_intro
    assume H
      apply false_elim (false = true âˆ§ b2 = true)
      apply discr_f_t apply H
  assume H apply conj_elim_left _ (b2 = true) apply H
qed

theorem or_true_iff b1 b2 : Ï€ (((or b1 b2) = true) â‡” (b1 = true âˆ¨ b2 = true))
proof
  assume b1 b2
  refine bool_ind (Î»z, imp ((or z b2) = true)
                           (z = true âˆ¨ b2 = true) âˆ§
                       imp (z = true âˆ¨ b2 = true)
                           ((or z b2) = true)) _ _ _
  // Case b1 = true
  simpl
  apply conj_intro
    assume H apply disj_intro_left apply H
    assume H reflexivity
  // Case b1 = false
  simpl
  apply conj_intro
    assume H apply disj_intro_right apply H
    assume H apply disj_elim (false = true) (b2 = true) (b2 = true) apply H
      assume Hfalse apply false_elim (b2 = true) apply discr_f_t apply Hfalse
      assume H2 apply H2
qed
