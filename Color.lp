// Inspir√© de Software_Foundations/lf/Basics.html
require open amelie.lambdapi_examples.Notation
require open amelie.lambdapi_examples.Bool
require open amelie.lambdapi_examples.Constructive_logic
require open amelie.lambdapi_examples.Discriminate

///////////////////////////////////////
// Definitions of type
///////////////////////////////////////

//Inductive rgb : Type :=
//  | red
//  | green
//  | blue.
constant symbol rgb : Set
constant symbol RGB : TYPE
rule œÑ rgb ‚Ü™ RGB
constant symbol red   : RGB
constant symbol green : RGB
constant symbol blue  : RGB

// Induction principle on RGB.
symbol rgb_ind :
     Œ†p, œÄ (p red) ‚Üí œÄ (p green) ‚Üí œÄ (p blue) ‚Üí Œ†c, œÄ (p c)


//Inductive color : Type :=
//  | black
//  | white
//  | primary (p : rgb).
constant symbol color : Set
constant symbol C : TYPE
rule œÑ color ‚Ü™ C
constant symbol black : C
constant symbol white : C
constant symbol primary : RGB ‚Üí C

// Induction principle on C.
symbol color_ind :
     Œ†p, œÄ (p black) ‚Üí œÄ (p white) ‚Üí (Œ†n, œÄ (p (primary n))) ‚Üí Œ†c, œÄ (p c)


//////////////////////////////////////////
// Some functions
//////////////////////////////////////////

//Definition monochrome (c : color) : bool :=
//  match c with
//  | black ‚Üí true
//  | white ‚Üí true
//  | primary q ‚Üí false
//  end.
symbol monochrome : C ‚Üí ùîπ
rule monochrome black     ‚Ü™ true
 with monochrome white     ‚Ü™ true
 with monochrome (primary _) ‚Ü™ false

//Definition isred (c : color) : bool :=
//  match c with
//  | black ‚Üí false
//  | white ‚Üí false
//  | primary red ‚Üí true
//  | primary _ ‚Üí false
//  end.
symbol isred : C ‚Üí ùîπ
rule isred black           ‚Ü™ false
 with isred white           ‚Ü™ false
 with isred (primary red)   ‚Ü™ true
 with isred (primary green) ‚Ü™ false
 with isred (primary blue)  ‚Ü™ false

// Definition isgreen (c : color) : bool :=
//   match c with
//   | black => false
//   | white => false
//   | primary green => true
//   | primary _ => false
//   end.
symbol isgreen : C ‚Üí ùîπ
rule isgreen black           ‚Ü™ false
 with isgreen white           ‚Ü™ false
 with isgreen (primary green) ‚Ü™ true
 with isgreen (primary red)   ‚Ü™ false
 with isgreen (primary blue)  ‚Ü™ false

// Definition isblue (c : color) : bool :=
//   match c with
//   | black => false
//   | white => false
//   | primary blue => true
//   | primary _ => false
//   end.
symbol isblue : C ‚Üí ùîπ
rule isblue black           ‚Ü™ false
 with isblue white           ‚Ü™ false
 with isblue (primary blue)  ‚Ü™ true
 with isblue (primary red)   ‚Ü™ false
 with isblue (primary green) ‚Ü™ false

////////////////////////////////////
// A proof of : forall c, isred c = true \/ isgreen c = true \/ isblue c = true <-> monochrome c = false
////////////////////////////////////

// Theorem my_color_test :
// forall c, isred c = true \/ isgreen c =true \/ isblue c = true
// <-> monochrome c = false.
// Proof.
// split;intro myHyp.
//  * induction c.
//     + destruct myHyp as [Hred|Hgreen_blue].
//         { discriminate Hred. }
//         { destruct Hgreen_blue as [Hgreen|Hblue].
//             - discriminate Hgreen.
//             - discriminate Hblue.
//         }
//     + destruct myHyp as [Hred|Hgreen_blue].
//         { discriminate Hred. }
//         { destruct Hgreen_blue as [Hgreen|Hblue].
//             - discriminate Hgreen.
//             - discriminate Hblue.
//         }
//     + induction p;reflexivity.
//  * induction c.
//     + discriminate myHyp.
//     + discriminate myHyp.
//     + induction p.
//         - left. reflexivity.
//         - right. left.  reflexivity.
//         - right. right. reflexivity.
// Qed.

///////////////////////////
// Right to left (RGB)
///////////////////////////
theorem right_to_left_rgb : Œ†n,
œÄ (monochrome (primary n) = false ‚äÉ isred (primary n) = true ‚à® isgreen (primary n) = true ‚à® isblue (primary n) = true)
proof
  refine rgb_ind (Œªz, monochrome (primary z) = false ‚äÉ
                                  isred (primary z) = true ‚à® isgreen (primary z) = true ‚à® isblue (primary z) = true) _ _ _
  // Goal red
  simpl
  assume Hyp apply disj_intro_left //(true = true) ((false = true) ‚à® (false = true))
  reflexivity
  // Goal green
  simpl
  assume Hyp apply disj_intro_right //(false = true) ((true = true) ‚à® (false = true))
  apply disj_intro_left // (true = true) (false = true)
  reflexivity
  // Goal blue
  simpl
  assume Hyp apply disj_intro_right //(false = true) ((false = true) ‚à® (true = true))
  apply disj_intro_right //(false = true) (true = true)
  reflexivity
qed

///////////////////////////
// Right to left (color)
///////////////////////////
theorem right_to_left_color :
Œ†c, œÄ ((monochrome c) = false ‚äÉ (isred c)=true ‚à® (isgreen c)=true ‚à® (isblue c)=true)
proof
  assume c
  apply color_ind (Œªz, (monochrome z) = false ‚äÉ (isred z)=true ‚à® (isgreen z)=true ‚à® (isblue z)=true) _ _ _ c
  // Goal black
  simpl assume Htruefalse
  apply false_elim apply discr_f_t symmetry apply Htruefalse
  // Goal white
  simpl assume Htruefalse
  apply false_elim apply discr_f_t symmetry apply Htruefalse
  // Goal primary
  assume rgb
  apply right_to_left_rgb rgb
qed

///////////////////////////
// Left to right (RGB)
///////////////////////////
theorem left_to_right_rgb : Œ†(n:RGB),
œÄ ((isred (primary n))=true ‚à® (isgreen (primary n))=true ‚à® (isblue (primary n))=true
        ‚äÉ (monochrome (primary n))=false)
proof
  assume n
  apply rgb_ind (Œªz,(isred (primary z))=true ‚à® (isgreen (primary z))=true ‚à® (isblue (primary z))=true
        ‚äÉ (monochrome (primary z))=false) _ _ _ n
  simpl assume Hyp reflexivity
  simpl assume Hyp reflexivity
  simpl assume Hyp reflexivity
qed

///////////////////////////
// Left to right (color)
///////////////////////////
theorem left_to_right_color :
Œ†c, œÄ ((isred c)=true ‚à® (isgreen c)=true ‚à® (isblue c)=true ‚äÉ (monochrome c) = false)
proof
  assume c
  apply color_ind (Œªz, (isred z)=true ‚à® (isgreen z)=true ‚à® (isblue z)=true ‚äÉ (monochrome z)=false) _ _ _ c
  // Goal black
  simpl assume Hor
  apply disj_elim (false = true) ((false = true) ‚à® (false = true))
     // 0. œÄ ((false = true) ‚à® ((false = true) ‚à® (false = true)))
     apply Hor
     // 1. œÄ (false = true) ‚Üí œÄ (true = false)
     assume Hfalsetrue symmetry apply Hfalsetrue
     // 2. œÄ ((false = true) ‚à® (false = true)) ‚Üí œÄ (true = false)
     assume Hor2 apply disj_elim (false = true) (false = true) apply Hor2
           assume Hfalsetrue symmetry apply Hfalsetrue
           assume Hfalsetrue symmetry apply Hfalsetrue
  // Goal white
  simpl assume Hor
  apply disj_elim (false = true) ((false = true) ‚à® (false = true))
     // 0. œÄ ((false = true) ‚à® ((false = true) ‚à® (false = true)))
     apply Hor
     // 1. œÄ (false = true) ‚Üí œÄ (true = false)
     assume Hfalsetrue symmetry apply Hfalsetrue
     // 2. œÄ ((false = true) ‚à® (false = true)) ‚Üí œÄ (true = false)
     assume Hor2 apply disj_elim (false = true) (false = true) apply Hor2
           assume Hfalsetrue symmetry apply Hfalsetrue
           assume Hfalsetrue symmetry apply Hfalsetrue
  // Goal primary
  assume rgb
  apply left_to_right_rgb rgb
qed

///////////////////////////////////
// Version ‚áî
///////////////////////////////////

theorem my_color_test :
Œ†c, œÄ ((isred c = true ‚à® isgreen c = true ‚à® isblue c = true) ‚áî (monochrome c = false))
proof
  assume c
  simpl
  apply conj_intro
  apply left_to_right_color c
  apply right_to_left_color c
qed




/////////////////////////////
// A weak version of the previous theorem
/////////////////////////////

theorem in_red_bis : Œ†c, œÄ (imp (eq {bool} (isred c) true) (eq {bool} (monochrome c) false))
proof
  assume c
  refine color_ind (Œªn, imp (eq {bool} (isred n) true) (eq {bool} (monochrome n) false)) ?CB[c] ?CW[c] ?CP[c] c
  // Goal : œÄ (imp (eq (isred black) true) (eq (monochrome black) false))
  simpl
  assume Hred
  rewrite Hred
  reflexivity
  // Goal : œÄ (imp (eq (isred white) true) (eq (monochrome white) false))
  simpl
  assume Hred
  rewrite Hred
  reflexivity
  // Goal : Œ†(n:RGB), œÄ (imp (eq (isred (primary n)) true) (eq (monochrome (primary n)) false))
  refine rgb_ind (Œªz, imp (eq {bool} (isred (primary z)) true) (eq {bool} (monochrome (primary z)) false)) ?CR[c] ?CG[c] ?CB[c]
  simpl
  assume Hred
  reflexivity
  //
  simpl
  assume Hred
  reflexivity
  //
  simpl
  assume Hred
  reflexivity
qed
